Семь лет назад Марк задал старт в моей карьере преподавания. Он вышел со мной на связь, так как ему понравилось как я выступаю на конференциях. Но я никогда не преподавал, и все равно Марк настоял на том, чтобы я хотя бы попробовал себя в этой отрасли. И у него ушло несколько недель на то, чтобы выбить из меня согласие, а мне не хотелось приезжать в снежно-холодную Миннесоту.

Но он потратил несколько недель на уговоры и я приехал сюда, далее проведя свой первый семинар. И в середине того дня я осознал, что это именно то, чем я хочу заниматься и то, чему я хочу себя посвятить, а именно преподаванию. Теперь все мое время посвящено преподаванию и я благодарен за это Марку.

И я никогда не забуду этот щедрый дар, и возвращаясь на площадку frontendmasters, я как будто бы возвращаюсь домой. Итак, на этом курсе мы будем говорить о JavaScript’e и в этом разговоре язык будет разбираться углубленно, не так, как вы привыкли его, возможно, поверхностно изучать. Некоторые люди могут знать меня по моему online-никнейму GETIFY.

Так что если вы читали мою ленту в Твиттере, особенно последние твиты, вы могли заметить, что мною упоминались многие темы, которые я планировал добавить в материал данного курса. Но вы можете найти все мои идеи на твиттере, ГитХабе, на слайде моя электронная почта.  Можете спокойно выходить со мной на связь или просто следить за моей online-деятельностью. 

Являюсь автором многих книг, включая серию книг «You Don’t Know JS». Большинство того, что мы будем разбирать содержится в первых трех книгах данной серии. Книга Область видимости и замыкания, книга  контекст this и прототипы объектов, а также книга Типы и Синтаксис. Это лучший источник дополнительной информации, после окончании данного курса.

Вы можете бесплатно скачать эти книги или, при желании купить - для меня это хорошая поддержка. Итак, я хочу поговорить с вами о том, почему мы будем углубленно анализировать JavaScript. Вместо того, чтобы всесторонне рассматривать фреймворки и аббревиатуры языка, почему мы планируем углубляться в поведение самого JavaScript’a и поговорим почему в этом есть смысл?

Так как может показаться, что в последнее время никто не пишет на чистом JavaScript. Они пишут на чем-то другом, будь это TypeScript, или абсолютно иной язык, такой как Go или Clojure. Но, кажется, что никто самостоятельно не прописывает свой JavaScript-код. Я имея ввиду, никто даже не публикует свой самостоятельно написанный JavaScript-код.  Они публикуют код, трансформированный 14 (четырнадцатью) слоями Babel’я.

Поэтому, есть ли смысл в нашем изучении и понимании, или стоит ли нам изучать и понимать JavaScript? Итак, я хочу, просто, побыстрому резюмировать то, что мы будем проходить  на данном курсе. Это, конечно, достаточно тривиальный код, но это то, с чем я недавно столкнулся и то, из чего извлек для себя что-то новое, готовя и подготавливаясь к этому курсу.

Многие из вас, возможно, уже знакомы с оператором ++ (плюс плюс). И когда он появляется в конце, т.е. в постфикс позиции, как указано здесь, на 3 строке. Когда он имеет постфикс позицию, он представляет из себя последующее увеличение. Т.е. вы сперва получите значение и только потом оно увеличится. Выходит, что вам дается значение, а затем оно увеличивается, поэтому выражение x++ все еще возвращает нам 40, но затем x увеличивается до 41-го.

И на 6 строке у нас идет предварительное увеличение, которое сперва обновляет, а уже потом возвращает значение, вот почему на 6 строке мы видим 42. У себя в голове я держал, да и думаю многие другие держали у себя в голове меняльную модель того, как работает оператор ++.

Да, есть нюансы типа «до» и «после», но в голове я представлял, что, в общем, этот ++ оператор равнозначен выражению x+1. И, мне кажется, что многие разделяют со мной это мнение. Поэтому, я начал копаться в этой теме… и позже вы начнете понимать, почему я  погружаюсь в такие глубокие размышления над различными нюансами языка.
 
Но я пытался понять, что если у нас есть ++ оператор на каком-нибудь значении и он на постфикс позиции, значит ли это, что значение возвращается без каких-либо модификаций, т.е. не тронутым. Я предполагал такое поведение, что нам возвращалось не тронутое значение и только затем оно обновлялось, каким-то механизмом, отвечающим за увеличение.

Отсюда возникает вопрос, что произойдет при использовании ++ оператора в пост-фикс позиции, при условии, что у нас не числовое значение? И на данном курсе мы немного затронем тему «типов данных и их приведения». И я буду углубленно разбирать данную тему,

Но вопрос в следующем: что происходит при строковом представлении числа, над которым проводится математическая операция, к примеру увеличение? В моем представлении, опять же, из-за проведения аналогии x++ с x = x + 1, я думал, ну это вернет  текстовую пятерку, а затем преобразует эту текстовую пятерку в реальное число 5, далее увеличивая ее до шести.


У меня была задана такая ментальная модель. И оказывается, хотя это и кажется логичным, на самом деле все работает иначе. Оказывается сперва значение преобразуется в число, по крайней мере мы видим такое поведение. Вы можете заметить, что я получил не текстовую пятерку на 7 строке, а числовую.

Получается оператор ++ выполняет операцию преобразования значения, до того как увеличить его. Таким образом оператор срабатывает не после, а где-то в середине. Немного странное поведение. Это был тот нюанс языка, о котором я никогда не задумывался. 

Я не говорю что вы будете натыкаться на такие проблемы в своем коде. Но этим я хочу подчеркнуть очень важный момент, а именно то, что мы, как разработчики, любим строить вокруг кода определенные ментальные модели. И когда появляются баги, заметьте я говорю когда, а не если, когда появляются баги мы начинаем винить язык, верно?

Мы виним язык, JavaScript явно был плохо спроектирован, раз уж наш код так странно себя повел. У меня много мнений по этому поводу. Те, кто подписан на меня знают, что у меня огромное количество мнений о работа JavaScript’a. И я никогда не был этим обделен. Я всегда говорил, что единственное в чем я являюсь экспертом, так это в моих собственных мнениях:)

Я никогда не был этим обделен. У меня много мнений о том, было ли добавление определенного поведения в JavaScript  хорошим или грамотным или мудрым решением. Но в чем я категорически не согласен, так это в том, что увидев поведение языка, которое вызывает у нас удивление, мы говорим,  как-то странно сработал код, значит виноват JavaScript.

Если мы спросим группу разработчиков C++: читали ли они хоть что-то из спецификации языка C++? В основном мы увидим поднятые руки, тоже самое с Java. Но если я задам тот же вопрос, что я и делаю, по всему миру я почти всегда задаю этот вопрос, кто из вас читал хоть что-то из спецификации JavaScript?

С трудом наберется хотя бы одна поднятая рука. И я думаю, что часть того, что я пытаюсь до вас донести, это что многие разработчики в JavaScript-комьюнити, любят думать о JavaScript, с его низким порогом вхождения, что он должен быть настолько интуитивно понятным, что если он не ведет себя так интуитивно, значит он был плохо спроектирован.

Как будто, на нас более не лежит ответственность в изучении того, как работают используемые нами инструменты. Поэтому если вы ищете какую-то всеобъемлющую тему того, что именно и почему я преподаю и особенно что этот курс дает, так это то, что мы делаем себе медвежью услугу, будучи разработчиками предполагая что-то, а это оказывается не правильным, и затем, когда это предположение нас подводит, мы начинаем обвинять других.

В это же время основная часть разработчиков других комьюнити говорят, ну, ошибку здесь допустил я, есть пробел в моих знаниях.  Поэтому здесь на слайде, когда я получил числовую 5-ку вместо текстовой, я не сказал, оу глупый JavaScript, как же тебя могли так плохо разработать?

У меня был вопрос почему, так произошло… И есть  только один ответ на этот вопрос. Значит вопрос того, читали ли вы когда-либо хотя бы часть спецификации, является вопросом, который никуда не денется и вы всегда должны его себе задавать. Если мне что-то не понятно, где же этот законодатель поведения языка?

У меня недавно был спор, где кто-то сказал: «ну не знаю, движок JavaScript’a - это законодатель поведения». Не, это не так. Спецификация - вот законодатель поведения. И если вы задумались над странным поведением кода, почему он себя так ведет, откуда баг, мистическое выполнение, абсолютное непонимание и тому подобное?

Первый вопрос, который вы должны задать: «а по спецификации, как именно срабатывает код»? И уже потом задавайтесь вопросом: «поведение, которое я вижу, совпадает ли оно со спецификацией языка»? Если в них есть несовпадения, ну, значит у вас в коде баг. Но если же все совпадает, значит у вас другого рода баг, и баг находится у вас в голове, у вас
дефектное мышление дефектное мышление.

